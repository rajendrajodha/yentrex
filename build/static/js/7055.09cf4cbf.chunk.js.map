{"version":3,"file":"static/js/7055.09cf4cbf.chunk.js","mappings":"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","sources":["../node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/viem/utils/abi/encodeErrorResult.ts","../node_modules/viem/utils/abi/encodeFunctionResult.ts","../node_modules/viem/utils/ens/localBatchGatewayRequest.ts","../node_modules/viem/utils/abi/decodeFunctionData.ts","../node_modules/viem/errors/ccip.ts","../node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import type { Abi, ExtractAbiErrors } from 'abitype'\n\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> | undefined = ContractErrorName<abi>,\n  ///\n  hasErrors = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiErrors<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractErrorArgs<\n    abi,\n    errorName extends ContractErrorName<abi>\n      ? errorName\n      : ContractErrorName<abi>\n  >,\n  allErrorNames = ContractErrorName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { errorName?: errorName | allErrorNames | undefined }\n      : { errorName: errorName | allErrorNames }\n    : { errorName?: errorName | allErrorNames | undefined }\n> &\n  (hasErrors extends true ? unknown : never)\n\nexport type EncodeErrorResultReturnType = Hex\n\nexport type EncodeErrorResultErrorType =\n  | GetAbiItemErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | EncodeAbiParametersErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function encodeErrorResult<\n  const abi extends Abi | readonly unknown[],\n  errorName extends ContractErrorName<abi> | undefined = undefined,\n>(\n  parameters: EncodeErrorResultParameters<abi, errorName>,\n): EncodeErrorResultReturnType {\n  const { abi, errorName, args } = parameters as EncodeErrorResultParameters\n\n  let abiItem = abi[0]\n  if (errorName) {\n    const item = getAbiItem({ abi, args, name: errorName })\n    if (!item) throw new AbiErrorNotFoundError(errorName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'error')\n    throw new AbiErrorNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!abiItem.inputs)\n      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath })\n    data = encodeAbiParameters(abiItem.inputs, args)\n  }\n  return concatHex([signature, data])\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionName,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n  result?:\n    | ContractFunctionReturnType<\n        abi,\n        AbiStateMutability,\n        functionName extends ContractFunctionName<abi>\n          ? functionName\n          : ContractFunctionName<abi>,\n        never // allow all args. required for overloads to work.\n      >\n    | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | undefined }\n      : { functionName: functionName | allFunctionNames }\n    : { functionName?: functionName | allFunctionNames | undefined }\n> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionResultReturnType = Hex\n\nexport type EncodeFunctionResultErrorType =\n  | AbiFunctionOutputsNotFoundError\n  | AbiFunctionNotFoundError\n  | EncodeAbiParametersErrorType\n  | GetAbiItemErrorType\n  | ErrorType\n\nexport function encodeFunctionResult<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionResultParameters<abi, functionName>,\n): EncodeFunctionResultReturnType {\n  const { abi, functionName, result } =\n    parameters as EncodeFunctionResultParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({ abi, name: functionName })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = (() => {\n    if (abiItem.outputs.length === 0) return []\n    if (abiItem.outputs.length === 1) return [result]\n    if (Array.isArray(result)) return result\n    throw new InvalidArrayError(result)\n  })()\n\n  return encodeAbiParameters(abiItem.outputs, values)\n}\n","import { batchGatewayAbi } from '../../constants/abis.js'\nimport { solidityError } from '../../constants/solidity.js'\nimport type { Hex } from '../../types/misc.js'\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js'\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js'\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js'\nimport type {\n  CcipRequestErrorType,\n  CcipRequestParameters,\n  CcipRequestReturnType,\n} from '../ccip.js'\n\nexport const localBatchGatewayUrl = 'x-batch-gateway:true'\n\nexport async function localBatchGatewayRequest(parameters: {\n  data: Hex\n  ccipRequest: (\n    parameters: CcipRequestParameters,\n  ) => Promise<CcipRequestReturnType>\n}): Promise<Hex> {\n  const { data, ccipRequest } = parameters\n\n  const {\n    args: [queries],\n  } = decodeFunctionData({ abi: batchGatewayAbi, data })\n\n  const failures: boolean[] = []\n  const responses: Hex[] = []\n  await Promise.all(\n    queries.map(async (query, i) => {\n      try {\n        responses[i] = query.urls.includes(localBatchGatewayUrl)\n          ? await localBatchGatewayRequest({ data: query.data, ccipRequest })\n          : await ccipRequest(query)\n        failures[i] = false\n      } catch (err) {\n        failures[i] = true\n        responses[i] = encodeError(err as CcipRequestErrorType)\n      }\n    }),\n  )\n\n  return encodeFunctionResult({\n    abi: batchGatewayAbi,\n    functionName: 'query',\n    result: [failures, responses],\n  })\n}\n\nfunction encodeError(error: CcipRequestErrorType): Hex {\n  if (error.name === 'HttpRequestError' && error.status)\n    return encodeErrorResult({\n      abi: batchGatewayAbi,\n      errorName: 'HttpError',\n      args: [error.status, error.shortMessage],\n    })\n  return encodeErrorResult({\n    abi: [solidityError],\n    errorName: 'Error',\n    args: ['shortMessage' in error ? error.shortMessage : error.message],\n  })\n}\n","import type { Abi, AbiStateMutability } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allFunctionNames extends\n    ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [functionName in allFunctionNames]: {\n          args: ContractFunctionArgs<abi, AbiStateMutability, functionName>\n          functionName: functionName\n        }\n      }[allFunctionNames]\n    >\n  : {\n      args: readonly unknown[] | undefined\n      functionName: string\n    }\n\nexport type DecodeFunctionDataErrorType =\n  | AbiFunctionSignatureNotFoundError\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | SliceErrorType\n  | ErrorType\n\nexport function decodeFunctionData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeFunctionDataParameters<abi>,\n) {\n  const { abi, data } = parameters as DecodeFunctionDataParameters\n  const signature = slice(data, 0, 4)\n  const description = abi.find(\n    (x) =>\n      x.type === 'function' &&\n      signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<abi>\n}\n","import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":["isAddressEqual","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase","docsPath","encodeErrorResult","parameters","abi","errorName","args","abiItem","item","getAbiItem","name","AbiErrorNotFoundError","type","undefined","definition","formatAbiItem","signature","toFunctionSelector","data","length","inputs","AbiErrorInputsNotFoundError","encodeAbiParameters","concatHex","localBatchGatewayUrl","async","localBatchGatewayRequest","ccipRequest","queries","slice","description","find","x","AbiFunctionSignatureNotFoundError","functionName","decodeAbiParameters","decodeFunctionData","batchGatewayAbi","failures","responses","Promise","all","map","query","i","urls","includes","err","error","status","shortMessage","solidityError","message","result","AbiFunctionNotFoundError","outputs","AbiFunctionOutputsNotFoundError","values","Array","isArray","InvalidArrayError","encodeFunctionResult","OffchainLookupError","BaseError","constructor","_ref","_cause$metaMessages","callbackSelector","cause","extraData","sender","super","metaMessages","url","concat","getUrl","flat","OffchainLookupResponseMalformedError","_ref2","stringify","OffchainLookupSenderMismatchError","_ref3","to","offchainLookupSignature","offchainLookupAbiItem","offchainLookup","client","blockNumber","blockTag","decodeErrorResult","callData","ccipRead","ccipRequest_","request","data_","call","Error","method","body","headers","_response$headers$get","response","fetch","replace","JSON","get","startsWith","json","text","ok","_result","HttpRequestError","details","statusText","isHex"],"ignoreList":[],"sourceRoot":""}