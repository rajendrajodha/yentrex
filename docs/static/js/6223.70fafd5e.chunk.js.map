{"version":3,"file":"static/js/6223.70fafd5e.chunk.js","mappings":"mIAMM,MAAOA,UAAgCC,EAAAA,GAQ3CC,WAAAA,CAAYC,EAAaC,GACvBC,QAJM,KAAAC,UAAW,EACX,KAAAC,WAAY,GAIlBC,EAAAA,EAAAA,IAAML,GACN,MAAMM,GAAMC,EAAAA,EAAAA,IAAQN,GAEpB,GADAO,KAAKC,MAAQT,EAAKU,SACe,oBAAtBF,KAAKC,MAAME,OACpB,MAAM,IAAIC,MAAM,uDAClBJ,KAAKK,SAAWL,KAAKC,MAAMI,SAC3BL,KAAKM,UAAYN,KAAKC,MAAMK,UAC5B,MAAMD,EAAWL,KAAKK,SAChBE,EAAM,IAAIC,WAAWH,GAE3BE,EAAIE,IAAIX,EAAIY,OAASL,EAAWb,EAAKU,SAASC,OAAOL,GAAKa,SAAWb,GACrE,IAAK,IAAIc,EAAI,EAAGA,EAAIL,EAAIG,OAAQE,IAAKL,EAAIK,IAAM,GAC/CZ,KAAKC,MAAME,OAAOI,GAElBP,KAAKa,MAAQrB,EAAKU,SAElB,IAAK,IAAIU,EAAI,EAAGA,EAAIL,EAAIG,OAAQE,IAAKL,EAAIK,IAAM,IAC/CZ,KAAKa,MAAMV,OAAOI,IAClBO,EAAAA,EAAAA,IAAMP,EACR,CACAJ,MAAAA,CAAOY,GAGL,OAFAC,EAAAA,EAAAA,IAAQhB,MACRA,KAAKC,MAAME,OAAOY,GACXf,IACT,CACAiB,UAAAA,CAAWC,IACTF,EAAAA,EAAAA,IAAQhB,OACRmB,EAAAA,EAAAA,IAAOD,EAAKlB,KAAKM,WACjBN,KAAKL,UAAW,EAChBK,KAAKC,MAAMgB,WAAWC,GACtBlB,KAAKa,MAAMV,OAAOe,GAClBlB,KAAKa,MAAMI,WAAWC,GACtBlB,KAAKoB,SACP,CACAT,MAAAA,GACE,MAAMO,EAAM,IAAIV,WAAWR,KAAKa,MAAMP,WAEtC,OADAN,KAAKiB,WAAWC,GACTA,CACT,CACAG,UAAAA,CAAWC,GAETA,IAAAA,EAAOC,OAAOrB,OAAOqB,OAAOC,eAAexB,MAAO,CAAC,IACnD,MAAM,MAAEa,EAAK,MAAEZ,EAAK,SAAEN,EAAQ,UAAEC,EAAS,SAAES,EAAQ,UAAEC,GAAcN,KAQnE,OANAsB,EAAG3B,SAAWA,EACd2B,EAAG1B,UAAYA,EACf0B,EAAGjB,SAAWA,EACdiB,EAAGhB,UAAYA,EACfgB,EAAGT,MAAQA,EAAMQ,WAAWC,EAAGT,OAC/BS,EAAGrB,MAAQA,EAAMoB,WAAWC,EAAGrB,OACxBqB,CACT,CACAG,KAAAA,GACE,OAAOzB,KAAKqB,YACd,CACAD,OAAAA,GACEpB,KAAKJ,WAAY,EACjBI,KAAKa,MAAMO,UACXpB,KAAKC,MAAMmB,SACb,EAaK,MAAMM,EAGTA,CAAClC,EAAaM,EAAY6B,IAC5B,IAAItC,EAAUG,EAAMM,GAAKK,OAAOwB,GAAShB,SAC3Ce,EAAKxB,OAAS,CAACV,EAAaM,IAAe,IAAIT,EAAUG,EAAMM,E","sources":["../node_modules/@noble/hashes/src/hmac.ts"],"sourcesContent":["/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n"],"names":["HMAC","Hash","constructor","hash","_key","super","finished","destroyed","ahash","key","toBytes","this","iHash","create","update","Error","blockLen","outputLen","pad","Uint8Array","set","length","digest","i","oHash","clean","buf","aexists","digestInto","out","abytes","destroy","_cloneInto","to","Object","getPrototypeOf","clone","hmac","message"],"ignoreList":[],"sourceRoot":""}