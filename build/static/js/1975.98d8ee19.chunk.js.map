{"version":3,"file":"static/js/1975.98d8ee19.chunk.js","mappings":"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","sources":["../node_modules/@web3-onboard/react/node_modules/@web3-onboard/core/node_modules/viem/_esm/errors/ccip.js","../node_modules/@web3-onboard/react/node_modules/@web3-onboard/core/node_modules/viem/_esm/utils/ccip.js","../node_modules/@web3-onboard/react/node_modules/@web3-onboard/core/node_modules/viem/_esm/utils/address/isAddressEqual.js"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupError'\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupResponseMalformedError'\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupSenderMismatchError'\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    const { ccipRead } = client;\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'\n        ? ccipRead.request\n        : ccipRequest;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipRequest_({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipRequest({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a, { strict: false }))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b, { strict: false }))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map"],"names":["OffchainLookupError","BaseError","constructor","_ref","_cause$metaMessages","callbackSelector","cause","data","extraData","sender","urls","super","shortMessage","metaMessages","length","map","url","concat","getUrl","flat","Object","defineProperty","this","enumerable","configurable","writable","value","OffchainLookupResponseMalformedError","_ref2","result","stringify","OffchainLookupSenderMismatchError","_ref3","to","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","async","offchainLookup","client","_ref4","blockNumber","blockTag","args","decodeErrorResult","abi","callData","ccipRead","ccipRequest_","request","ccipRequest","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase","isAddressEqual","data_","call","encodeAbiParameters","err","_ref5","error","Error","i","method","includes","body","undefined","_response$headers$get","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","_result","HttpRequestError","details","statusText","status","isHex","message"],"ignoreList":[],"sourceRoot":""}